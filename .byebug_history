c
filtered
c
filtered.count
filtered
c
required_dif
quit
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
quit
limits
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
c
limits
r.rsi
c
strategy.marks.first.limits
strategy.marks
strategy.computed_required.map(&:rsi)
strategy.computed_required.pluck(:rsi)
strategy.computed_required.count
strategy.computed_required
strategy.filter_computed
c
strategy.filter
c
quit
limits.first
limits
c
self.limits
limits
c
mark.filter_computed.count
mark.filter_computed
mark.limits
strategy.computed_required
quit
required_dates_count.keys.sample.match /[^\d{4}\/\d{1,2}\/\d{1,2}]/
required_dates_count.keys.match /[^\d{4}\/\d{1,2}\/\d{1,2}]/
required_dates_count.keys.match [^\d{4}\/\d{1,2}\/\d{1,2}]
required_dates_count.keys.match /[^\d{4}\/\d{1,2}\/\d{1,2}]/
required_dates_count.keys.sample =~ /[^\d{4}\/\d{1,2}\/\d{1,2}]/
date_format
required_dates_count.keys.sample =~ date_format
required_dates_count.keys.sample
required_dates_count.sample
quit
strategy.computed_required.first.send(required.last.indicator_symbol)
required.last
required.first
strategy.computed_required.first.adtv
strategy.computed_required.first
quit
dates.keys.select { |d| dates[d] == 2 }
dates
quit
dates.keys.select { |s| s == "2019-05-07" }
dates.keys.each {}
dates.keys
dates.map(&:key)
dates
quit
dates.first
dates.class
dates
dates.first.key
dates.first
dates
quit
computed_required.map(&:date_time)
computed_required.first.date_time
computed_required.first(&:date_time)
computed_required.first
computed_required.class
computed_required
c
marks.required.first.indicator
marks.required.count
marks.count
quit
Indicator.all
Indicator.all.first
Indicator.first
required
required.first
requires.first
i
c
Mark.where(strategy_id: 28).count
strategy.id
strategy.marks
quit
strategy.computed_non_required.sample.first
strategy.computed_non_required.sample.count
strategy.computed_non_required.first.count
strategy.computed_non_required.last.count
strategy.computed_required.last.count
strategy.computed_required.first.count
strategy.computed_required.first.class
c
strategy.non_required_dates_count
c
strategy.non_required_dates_count
c
strategy.non_required_dates_count
c
strategy.non_required_dates_count
first_non_required
c
strategy.computed_required.first.count
strategy.computed_required.first
quit
marks.required.map(&:indicator).class
marks.required.map(&:indicator)
marks.required.select(&:indicator)
marks.required
marks
c
Kernel.const_get("TechnicalAnalysis::" + params[:indicator].camelize).valid_options
accepted_params
c
options
c
options.transform_keys!(&:to_sym)
options
c
options
options.slice(*valid_options)
c
options.slice(*valid_options)
valid_options.slice(*valid_options)
valid_options
c
{ price_key: :close, volume_key: :volume }.merge(params.slice(*accepted_params))
params.slice(*accepted_params)
c
params.slice(*["fast_period", "slow_period"])
params.slice(["fast_period", "slow_period"])
params
quit
params.slice("fast_period")
params.slice(accepted_params)
accepted_params
params
options
c
options.slice(*valid_options)
c
options
options.slice(*valid_options)
c
"TechnicalAnalysis::" + name.camelize
Kernel.const_get("TechnicalAnalysis::" + name.camelize).valid_options
options.slice(*valid_options)
c
options
c
params
options
c
params.slice(":period")
params
c
results.last.date_time.to_date
results.last.date_time
c
Time.current
Time.new("21/05/2020")
DateTime.new("21/05/2020")
Time.new("21/05/2020")
results.last.date_time.to_date
results.first.date_time.to_date
results.first.date_time.to_date - Time.current
results.first.date_time.to_date > Time.current
results.first.date_time.to_date < Time.current
results.first.date_time.to_date
Time.current
results.first.date_time < Time.current
results.first.date_time
results.first
c
data
c
input_data
c
data
c
input_data
c
data
c
data
c
data
quit
data.first
data
quit
TechnicalAnalysis::Validation.validate_date_time_key(data)
TechnicalAnalysis::Validation.validate_numeric_data(data, :high, :low, :close, :volume)
data.count
data
TechnicalAnalysis::Indicator.calculate(name, data, :technicals, {})
TechnicalAnalysis::Indicator.calculate(name, data, :technicals)
TechnicalAnalysis::Indicator.calculate(name, data)
name
quit
Indicator.new(name: params[:indicator], options: options).calculate
Indicator.new(name: params[:indicator], options: options)
Indicator.new(params[:indicator], options)
Indicator.new(params[:indicator], options).calculate
User.new("sd@f.ly").email
User.new("sd@f.ly")
User.new
quit
User.new
Indicator.new
Indicator.new(params[:indicator], options)
quit
c
Indicator.new
Indicator.new(params[:indicator], options)
quit
Indicator.new
Indicator
quit
Indicator.connection
